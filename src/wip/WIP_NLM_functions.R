# Rscript version of neutral_lineage_markers.Rmd to run from terminal
# to do: x ticks only at time points of PCA plots

# libraries and functions -------------------------------------------------
library(docstring)
library(tidyverse)
library(data.table)
library(foreach)
library(doParallel)
library(parallel)
nr_cores <- detectCores() - 1
options(scipen = 999)

source('readNumpyByTime.R') #utility file
source('computeCoordinates.R') #utility file
source('readGridLineage.R')  # utility function to read deprecated grid lineage file
source('getGridsize.R')
source('read_and_plot_external_metabolites.R')
source('../utility/readSpeciesCounts.R')


plotSim <- function(prot_rds, species_rds, cols = c(colour1, colour2))  {
  #' @title Make 3 ggplot2 objects for a simulation
  #' @description Main function to call. This function takes the processed proteome 
  #' and species_counts data from a single simulation, and plots lineage frequencies over time, 
  #' snapshots of lineage makers on the grid, and a PCA of single-cell proteomes. 
  #' For clarity you can provide two optional hex colours, to make sure that if two 
  #' lineages survive they have contrasting colours.
  #' @param prot_rds processed proteome data (generated by readFig2data.R)
  #' @param species_rds processed species_counts data (generated by readFig2data.R)
  #' @param cols a list of two optional hex colour for first and second of two surviving lineage markers
  #' @return a list of 3 ggplot2 objects:
  #' \item{$lineage:}{lineage marker frequencies vs time}
  #' \item{$grid:}{snapshots of lineage marker frequences on the grid for 10 time points along the simulation}
  #' \item{$PCA:}{pca of single-cell proteomes for 10 time points along the simulation}
  
  
  if(!file.exists(prot_rds)){
    stop('Error - prot_rds file does not exists')
  }
  if(!file.exists(species_rds)){
    stop('Error - species_rds file does not exists')
  }
  
  
  # functions ---------------------------------------------------------------
  
  makePCA <- function(df_prot)  {
    # returns PC 1-3 for plotting
    
    cat('making PCA', '\n')
    # Normalise protein expression
    df.normalised <- df_prot
    df.normalised[, -c(1:4, 64)] <- df.normalised[, -c(1:4, 64)] / rowSums(df.normalised[, -c(1:4, 64)])
    
    labels <- c('time', 'lineage', 'gridpoint', 'x', 'y')
    
    for_pca <- df.normalised %>%
      filter(time != 0) %>%
      select(-labels) %>% # only select reactions
      filter_all(any_vars(. != 0))  # remove all zero rows (empty grid points)
    
    var0 <-
      unlist(lapply(for_pca, function(x)
        0 == var(if (is.factor(x))
          as.integer(x)
          else
            x)))
    for_pca <- for_pca[,!var0]
    pca <- prcomp(for_pca, center = TRUE, scale = TRUE)
    
    # calculate proportions of variance
    PoV <- pca$sdev ^ 2 / sum(pca$sdev ^ 2)
    PoV <- round(100 * PoV, digits = 2)
    
    labels <- df.normalised %>%
      filter(time != 0) %>%                                                                                    # why remove t=0?
      filter_at(vars(-c(time, lineage, x, y, gridpoint)),
                any_vars(. != 0)) %>%
      select(labels)
    
    # Reattach labels to the PCA data
    for_plot <-
      as.data.frame(cbind(labels, pca$x[, c(1:4)]))
    
    # for_plot$lineage  <-
    #   factor(for_plot$lineage, levels = -1:lin_max)
    
    return(for_plot)
  }
  
  
  plotPCA <- function(for_plot)  {
    
    cat('creating PCA plot', '\n')
    
    # figure out coordinates for text insert
    xmin <- for_plot %>% 
      filter(time %in% t_plot) %>% 
      filter(PC1 == min(.$PC1)) %>% 
      select(PC1) %>%
      unlist(.)
    
    ymin <- for_plot %>% 
      filter(time %in% t_plot) %>% 
      filter(PC2 == min(.$PC2)) %>%
      select(PC2) %>% 
      unlist(.)
    
    time_stamps <- data.frame(
      'labels' = paste('t =', seq(1:10)), 
      'time' = seq(100000, 1000000, by = 100000), 
      'x' = rep(xmin, 10), 
      'y' = rep(ymin, 10)
    )
    
    
    pca_lin <- for_plot %>%
      filter(time %in% t_plot) %>%
      ggplot(aes(x = PC1, y = PC2)) +
      geom_vline(xintercept = 0,
                 size = 0.5,
                 col = 'grey') +
      geom_hline(yintercept = 0,
                 size = 0.5,
                 col = 'grey') +
      facet_wrap(~ time, nrow = 1) +
      geom_point(aes(color = lineage), size = 1, alpha = 1) + # We can color mtab_4, mtab_16, or mtab_all
      theme_void() +
      scale_colour_manual(values = lin_col, drop = FALSE)  +
      theme(
        legend.position = 'none',
        aspect.ratio = 1,
        panel.border = element_rect(
          colour = "black",
          fill = NA,
          size = 0.5
        ),
        panel.spacing = unit(1.4, 'lines'),
        strip.background = element_blank(),
        strip.text.x = element_blank(),
        strip.text.y = element_text(size = 5),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_text(size = 7),
      ) +
      xlab('') +
      ylab('') + 
      geom_text(data = time_stamps,
                aes(x = x, y =y, label = labels, hjust = 'left', vjust = 'bottom')
      ) 
    
    return(pca_lin)
  }
  
  
  plotSpeciesCounts <- function(species_counts)  {
    
    cat('creating lineage marker plot', '\n')
    
    myplot <- species_counts %>%
      filter(time_point %in% sq) %>%
      ggplot(aes(x = time_point)) +
      geom_line(aes(y = fraction, col = lineage), size = 1) +
      theme_classic() +
      theme(
        legend.position = 'none',
        axis.text.x = element_text(size = 15),
        axis.text.y = element_text(size = 15),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12)
      ) +
      ylab('Frequency') +
      xlab(expression(paste('Time (', 10 ^ {
        5
      }, ' a.u.t.)'))) +
      scale_x_continuous(
        limits = c(0, tmax),
        expand = c(0, 0),
        breaks = c(0, t_plot),
        labels = function(x)
          x / 100000
      ) +
      scale_y_continuous(
        limits = c(0.001, 1.0),
        breaks = scales::pretty_breaks(n = 2), 
        expand = c(0,0)
      ) +
      scale_colour_manual(values = lin_col, drop = FALSE) 
    
    return(myplot)
  }
  
  
  plotGridLin <- function(df_prot)  {
    
    cat('creating lineage grid plot', '\n')
    
    myplot <-  df_prot %>%
      filter(time %in% t_plot) %>%
      ggplot() +
      geom_tile(aes(x = x, y = y, fill = lineage)) +
      theme_void() +
      facet_wrap(~ time, nrow = 1) +
      theme(
        legend.position = 'none',
        aspect.ratio = 1,
        strip.background = element_blank(),
        strip.text.x = element_blank(),
        strip.text.y = element_text(size = 6),
        panel.spacing = unit(1.4, 'lines')
      ) + 
      scale_fill_manual(values = lin_col, drop = FALSE) +
      scale_x_continuous(expand=c(0,0)) +
      scale_y_continuous(expand=c(0,0))
    
    return(myplot)
  }
  
  
  linColRainbow <- function(df_prot, lin_max, cols)  {
    
    isColor <- function(X) {
      tryCatch(is.matrix(col2rgb(X)), 
               error = function(e) FALSE)
    }
    
    lin_col <- c("#000000FF", sample(rainbow(gridwidth^2 + 2)))
    
    if(isColor(cols[1]) && isColor(cols[2]))
    {
      cat('using provided colours\n')
      #set contrasting colours for final 2 lineages
      
      surviving_lineages <- df_prot %>%
        filter(time == max(time)) %>%
        select(lineage) %>%
        distinct(.) %>%
        unlist(.) %>%
        as.character(.) %>%
        sort(.)
      surviving_lineages <- as.numeric(surviving_lineages) + 2
      
      if (length(surviving_lineages) == 4) {
        lin_col[surviving_lineages] <- c('black', 'red', 'cyan', 'blue')
      }
      if (length(surviving_lineages) == 3) {
        lin_col[surviving_lineages] <- c('black', 'cyan', 'blue')
      }
      if (length(surviving_lineages) == 3) {
        lin_col[surviving_lineages] <- c('black', cols[1], cols[2])
      }
      
      ### alternate way to get contrasting colours for CF
      # # if 2 lineages survive, print IDs
      # lastline <- speciesCounts[which(speciesCounts$time_point == xmax),]
      # nonzero <- which(lastline != 0)[-1] # column NUMBERS of remaining lineages
      # if (length(nonzero) < 3) {
      #   colnames(lastline)[nonzero]
      #   cat('Surviving lineages at t=', xmax, ': ')
      #   cat(colnames(lastline)[nonzero], '\n')
      #   for_print <- Filter(function(x)!all(is.na(x)), lastline)
      #   print(for_print, '\n')
      # }
      #
      #
      # # Plotting 
      #
      # #colours <- sample(scan('/home/jeroen/R_projects/cols20.txt', what = 'character'), 19)
      # colours <- scan('/home/jeroen/R_projects/cols20.txt', what = 'character', quiet = TRUE)
      #
      # # adjust colours is colours of 2 surviving lineages are the same
      # if (length(nonzero) < 3){
      #   lin1 <- as.numeric(colnames(lastline)[nonzero][1])
      #   lin2 <- as.numeric(colnames(lastline)[nonzero][2])
      #   if(lin1%%length(colours) == lin2%%length(colours)){
      #     colours <- sample(colours, length(colours)-1)
      #   }
      # }
      #
    } else{
      cat('using default colours\n')
    }
    

    return(lin_col)
  }
  
  
  

  # main function body ------------------------------------------------------
  
  cat('reading proteome data', '\n')
  df_prot <- readRDS(prot_rds)
  cat('reading lineage data data', '\n')
  species_counts <- readRDS(species_rds)
  
  lin_col <- linColRainbow(df_prot, lin_max, cols) 
  
  plot_sp <- plotSpeciesCounts(species_counts) 
  plot_sp <- plot_sp +  
    ggtitle("Lineage tracking") + 
    theme(plot.margin = margin(1.4, 1, 0, 0, unit = 'lines'))
  
  plot_gl <- plotGridLin(df_prot) 
  plot_gl <- plot_gl +
    ggtitle("Grid Snapshots") + 
    theme(plot.margin = margin(0, 1, 0, 0, unit = 'lines'), 
          plot.title = element_text(vjust = 2.5)
    )
  
  
  df_pca <- makePCA(df_prot)
  plot_pca <- plotPCA(df_pca)
  plot_pca <- plot_pca +
    ggtitle("PCA of single-cell proteomes (one dot = one cell)") +
    theme(plot.margin = margin(0, 1, 0, 0, unit = 'lines'),
          plot.title = element_text(vjust = 2.5)
    )
  
  return(list('lineage' = plot_sp, 'grid' = plot_gl, 'pca' = plot_pca))
  
}



# getTmax <- function(folder)  {
#   temp <- read.csv(paste0(folder, '/data/population_dat/population_size.csv'), 
#                    header = TRUE)
#   return(max(temp$time_point))
# }
# 


